# [백준 1138 한 줄로 서기](https://www.acmicpc.net/problem/1138)

solved.ac Silver II

## 카테고리

구현

## 시간복잡도

키가 1 ~ N인 모든 사람을 한번씩 모두 검사하므로 첫번째 for문에서 O(n),
안쪽에서 빈칸을 세며 적절한 위치를 찾는 두개의 while문에서 O(n)으로
O(n ^ 2) 연산이다.

## 풀이
**⏱️소요시간 40분**<br>
이 문제는 본인보다 왼쪽에 키가 큰 사람의 수로 사람 순서를 구하는 문제로 풀이방법은 크게 아래와 같이 두가지로 나뉜다.
1. 키가 작은 사람부터 생각한다.
2. 키가 큰 사람부터 생각한다.

필자는 1번의 과정으로 문제를 풀었고 1번 과정을 상세히 설명한 후 2번 과정도 간략하게 알아볼 예정이다.

문제는 다음과 같은 법칙에 따라 접근했다.
1. 키가 가장 작은 사람은 왼쪽에 큰 사람 수만큼 빈칸을 두고 위치해야 한다.
2. 큰 사람 수만큼 빈칸을 두었지만 계산한 칸이 차있을 수 있다. 해당 칸에 있는 난쟁이같은 사람을 배려해줘야 하므로 빈칸이 나올 때 까지 오른쪽으로 이동하여 위치한다.

이해하기 쉽게 그림으로 이해를 돕겠다. 다음과 같은 입력을 받았다고 예를 들자.

N = 7<br>
6 1 1 1 2 0 0 

키가 1인 사람은 본인보다 왼쪽 6칸에 큰 사람이 와야하므로 7번째 칸에 들어간다.
|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|
|||||||<span style="color:red">1</span>|

1이 이미 자리를 차지하고 있으므로 2는 그 다음 작은 사람이다. 2는 무조건 자기 왼쪽에 빈칸이 1개 있어야 한다.
|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|
||<span style="color:red">2</span>|||||1|

1,2가 자리를 차지하고 있으므로 3은 그 다음 작은 사람이다. 3은 무조건 자기 왼쪽에 빈칸이 1개 있어야 한다.
**하지만 해당 위치에는 이미 2가 있으므로 2번 원칙에 의해 오른쪽에서 가장 가까운 빈칸으로 찾아가야 한다.** 
|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|
||2|<span style="color:red">3</span>||||1|

그다음 작은 사람인 4도 왼쪽에 빈칸이 1개 있어야 한다. 하지만 2번, 3번 칸이 모두 차있으므로 4는 4번칸에 들어간다.
|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|
||2|3|<span style="color:red">4</span>|||1|

이제 코드로 구현해보자. 결과를 저장할 자료구조는 1차원 배열로 선언하였다. 배열의 크기가 N + 1인 이유는... 없다. 컴파일 할 때 OutOfRangeException을 피하고 일단 로그를 찍어보기 위해서 넉넉하게 선언했다.
```java
// 자료구조 선택
int[] result = new int[N + 1];
```

1,2번 원칙은 아래와 같은 구현 코드로 변환된다.
```java
// 구현
for (int height = 1; height <= N; height++) {
    int left = arr[height]; // left는 키가 height인 사람 왼쪽에서 height 보다 큰 사람 수
    int idx = 0; // result 배열에 들어가야할 직접적인 인덱스
    int cnt = 0; // 현재까지 체크한 더 큰 사람 수
    while (cnt != left) {
        if(result[idx] == 0) cnt++;
        idx++;
    }
    while(result[idx] != 0) {
        idx++;
    }
    result[idx] = height;
}
```

간단한 로직으로 금방 구현이 가능하다.

## 결과

결과 : [맞았습니다!!](https://www.acmicpc.net/source/63759087)

## 추신
짧게 완전히 다른 접근 풀이도 보겠다. 아래는 위에서 언급한 키가 큰 사람부터 접근한 풀이법이다. 
```java
public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    int n = scan.nextInt();
    int [] tall = new int[n+1];
    List<Integer> ans = new ArrayList<>();

    for(int i=1; i<=n; i++) {
        tall[i] = scan.nextInt();
    }

    for(int i=n; i>=1; i--) {
        ans.add(tall[i], i);
    }

    for(int k : ans) {
        System.out.print(k+" ");
    }
}
```
~~Scanner부터 마음에 안든다.~~
### 풀이
간단하다. 키가 큰 순으로 입력받은 키 대로 ArrayList 해당 위치에 삽입해주면 된다.

키가 4인 사람 -> 0 / 0번째에 삽입 -> [4]

키가 3인 사람 -> 1 / 1번째에 삽입 -> [4, 3]

키가 2인 사람 -> 1 / 1번째에 삽입 -> [4, 2, 3]

키가 1인 사람 -> 2 / 2번째에 삽입 -> [4, 2, 1, 3]

ArrayList에서 주어진 인덱스에 원소를 추가하는 연산은 O(n)연산이다. 풀이를 써주신 분께서 왜 인덱스 추가 연산이 O(1)인 LinkedList를 사용하지 않았는가는 의문이 들지만 코드가 훨씬 직관적이고 간단해서 가져와봤다.