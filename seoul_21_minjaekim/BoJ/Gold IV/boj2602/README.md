# [BoJ 2602 돌다리 건너기](https://www.acmicpc.net/problem/2602)

## 카테고리

다이나믹 프로그래밍

## 시간복잡도

두루마리길이를 N, 다리길이를 M이라고 할 때, O(N*M)이다.

## 해설

각 다리를 건너는 방법의 수를 추적하기 위한 3차원 DP 배열이다.

[2]는 어느 다리부터 시작하는지에 따른 2가지 경우를 나눠서 저장하기 위한 배열이다.

[20]은 두루마리에 적힌 문자열의 몇번째 문자를 읽고 있는지에 따른 20가지 경우를 나눠서 저장하기 위한 배열이다.

[100]은 두루마리에 적힌 문자열과 같은 문자의 발판이 몇개가 있는지 누적하여 저장하기 위한 배열이다.

```cpp
int dp[2][20][100] = {0,};
```

첫번째 발판을 악마다리부터 시작했다면, 두번째 발판은 천사다리, 세번째 발판은 악마다리가 되어야 한다.
어느 다리부터 시작했는지와, 몇 번째 발판인지를 이용해 어느 다리를 밟아야 하는지 계산해준다.

```cpp
int devil_or_angel = (i + j) % 2;
```

첫 발판은 누적시켜나갈 기존 발판과 비교할 필요가 없으므로, 따로 처리해준다.

```cpp
if (j == 0)
    dp[i][0][0] = (target[0] == bridge[devil_or_angel][0]);
```

두루마리의 순서에 맞게 j번째의 두루마리 발판을 밟을 수 있는 경우의 수는, j - 1번째의 두루마리 발판을 밟을 수 있는 경우의 수를 누적시킨다.

예를 들어 두루마리가 `ABC`이고, 악마의 다리가 `AAACC`, 천사의 다리가 `BBBBB`일 때, 악마의 다리부터 시작했다면 다음과 같이 계산될 수 있다.

|  악마 | A | A | A | C | C |
| :-:   |:-:|:-:|:-:|:-:|:-:|
|  천사 | B | B | B | B | B |
|A(악마)| 1 | 2 | 3 | 0 | 0 |
|B(천사)| 0 | 1 | 3 | 6 | 0 |
|C(악마)| 0 | 0 | 0 | 3 | 9 |

위의 표와 같이 두루마리와 같이 발판을 밟을 수 있는 경우의 수를 누적시켜나가면, 마지막 발판을 밟을 수 있는 경우의 수를 구할 수 있다.

```cpp
for (int k = 1; k < int(bridge[i].size() - target.size()) + j + 1; ++k) {
    if (target[j] == bridge[devil_or_angel][k]) {
        if (j == 0)
            dp[i][j][k] = dp[i][j][k - 1] + 1;
        else
            dp[i][j][k] = dp[i][j][k - 1] + dp[i][j - 1][k - 1];
    }
    else {
        dp[i][j][k] = dp[i][j][k - 1];
    }
}
```

## 성능 요약

메모리: 2024 KB, 시간: 0 ms

결과 : [맞았습니다!!](http://boj.kr/a04571028f124340a045f3ccd400eaa5)